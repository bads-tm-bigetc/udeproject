/* ########################################################################

   udrb2gtkd - Ultimate Desktop Resource Database To GTK Demon.

   ########################################################################

   Copyright (c) : Christian Ruppert

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

   ######################################################################## */

/* This is an EXTREMELY quick and dirty c-program (in fact i'ld rather call it
   a perl script than a c program, people knowing my opinion about the coding
   discipline of most perl scripters know what i mean). However it works for
   me and there won't be a proper solution anyhow until the GTK-folks decide
   to implement X resource support into their library.

   !!! DO NOT SEND ANY BUG REPORTS OR FEATURE REQUESTS OR WHATEVER ABOUT  !!! 
   !!! THIS PROGRAM. I KNOW IT IS VERY IMPROPER BUT WHAT WOULD YOU EXPECT !!!
   !!! FROM A WRAPPER PROGRAM AROUND AN IMPROPER CONFIGURATION MECHANISM  !!!
   !!! AS IN GTK. IF YOU WANT A PROPER/BETTER SOLUTION OR CONFIGURABILITY !!!
   !!! OR WHATEVER EITHER IMPLEMENT IT YOURSELF OR WRITE A REQUEST TO THE !!!
   !!! GTK TEAM TO SUPPORT THE X RESOURCE DATABASE FOR CONFIGURATION.     !!!
   
   i also known that the mapping between ude and gtk resources is some kind of
   strange (esp. using shadowcolor as background for text widgets. this is due
   to the brainless gtk politics of using text background colors also with
   standard foreground colors and since using standard foreground on text
   background often results in something unreadable i decided to do so. again,
   if you don't like this send a bug report to the gtk-guys instead of me. */

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <X11/Xutil.h>
#include <X11/Xresource.h>

Display *disp;
char *gtkrc, *gtkrcbackup;
const char *filename = "/.gtkrc";
const char *backupfilename = "/.gtkrc.urdb2gtkc_bak";
int run = -1;
int backup = 0;
int berrno;
int writing = 0;

#define MAP_SIZE 22
struct urdb2gtk_map {
  char *urdb;
  char *gtk;
} map[MAP_SIZE] = {
	{"background", "bg[NORMAL]"},
	{"standardtext", "fg[NORMAL]"},
	{"shadowcolor", "bg[ACTIVE]"},
	{"standardtext", "fg[ACTIVE]"},
	{"lightcolor", "bg[PRELIGHT]"},
	{"standardtext", "fg[PRELIGHT]"},
	{"lightcolor", "bg[SELECTED]"},
	{"standardtext", "fg[SELECTED]"},
	{"background", "bg[INSENSITIVE]"},
	{"lightcolor", "fg[INSENSITIVE]"},
	{"shadowcolor", "base[NORMAL]"},
	{"textcolor", "text[NORMAL]"},
	{"shadowcolor", "base[ACTIVE]"},
	{"textcolor", "text[ACTIVE]"},
	{"shadowcolor", "base[PRELIGHT]"},
	{"textcolor", "text[PRELIGHT]"},
	{"highlightedbgr", "base[SELECTED]"},
	{"highlightedtext", "text[SELECTED]"},
	{"shadowcolor", "base[INSENSITIVE]"},
	{"lightcolor", "text[INSENSITIVE]"},
	{"standardfont", "font"},
	{"textfont", NULL}};

void update_gtkrc() {
  int a;
  FILE *file;
  XrmDatabase db;
  char **db_strings = NULL;
  int db_count;
  XTextProperty db_prop;
  
  if((!XGetTextProperty(disp, RootWindow(disp, DefaultScreen(disp)),
			&db_prop, XA_RESOURCE_MANAGER))
     || (!XTextPropertyToStringList(&db_prop, &db_strings, &db_count))) {
    fprintf(stderr,
          "urdb2gtkd - ERROR: could not get resource database - not writing\n");
    if(db_strings) XFreeStringList(db_strings);
    return;
  }
  XFree(db_prop.value);
  db = XrmGetStringDatabase(db_strings[0]);
  XFreeStringList(db_strings);
  writing = -1;
  if(!(file = fopen(gtkrc, "w"))) {
    fprintf(stderr,
            "urdb2gtkd - ERROR: could not open %s for writing - not writing\n",
	    gtkrc);
    XrmDestroyDatabase(db);
    writing = 0;
    return;
  }
  fprintf(file, "# this file has been autogenerated by the urdb2gtk demon\n");
  fprintf(file, "\nstyle \"default\" {\n");
  for(a = 0; a < MAP_SIZE; a++) {
    XrmValue val;
    char b[256], *type;
    sprintf(b, "ude.%.250s", map[a].urdb);
    if(XrmGetResource(db, b, map[a].urdb, &type, &val)) {
      if(map[a].gtk) fprintf(file, "  %s = \"%s\"\n", map[a].gtk, val.addr);
    }
  }
  XrmDestroyDatabase(db);
  /* XrmGetStringDatabase/XrmDestroyDatabase seem to leak memory at least on
     my XF4.2.1. this makes this program bigger and bigger the more you change
     workspaces... not my fault however - and hey, you're using gtk-apps: the
     few extra bytes of wasted memory shouldn't really matter ;) */
  fprintf(file, "}\nclass \"*\" style \"default\"\n");
  fclose(file);
  writing = 0;
}

void drop_out(int i) {
  if(backup) rename(gtkrcbackup, gtkrc);
  else if(berrno == ENOENT) unlink(gtkrc);
  exit(i);
}

void HupHandler(int i) {
  if(writing) run = 0;
  else drop_out(0);
}

int XEH(Display *d, XErrorEvent *e) {
  HupHandler(0);
}

int main(int argc, char *argv[]) {
  char *homedir;
  char dump = 0;
  struct stat dummy;

  if((argc == 2) && (!strcmp(argv[1], "--dump"))) {
    dump = -1;
  } else if(argc != 1) {
    char *help[] = {
      "  --dump: dump resources to file and exit.",
      "  else run in background and keep file up to date.",
      "!!! proper termination in background mode with SIGHUP, do     !!!",
      "!!! not send KILL if you want to keep your .gtkrc consistent. !!!",
      NULL};
    int a;
    printf("\nusage:\n  %s [--dump]\n\n", argv[0]);
    for(a = 0; help[a] != NULL; a++) printf("%s\n", help[a]);
    exit(0);
  }
  if(!(homedir = getenv("HOME"))) {
    homedir = ".";
  }
  if((!(gtkrc = calloc(strlen(homedir) + strlen(filename) + 1, sizeof(char))))
     || (!(gtkrcbackup = calloc(strlen(homedir) + strlen(backupfilename) + 1,
                                sizeof(char))))) {
    fprintf(stderr, "urdb2gtkd - FATAL ERROR: not enough memory, exiting.\n");
    exit(1);
  }
  sprintf(gtkrc, "%s%s", homedir, filename);
  sprintf(gtkrcbackup, "%s%s", homedir, backupfilename);
  signal(SIGHUP, HupHandler);

  if(!dump) {
    if(stat(gtkrc, &dummy)) {
      berrno = errno;
    } else {
      backup = 1;
      rename(gtkrc, gtkrcbackup);
    }
  } else {
    berrno = ECANCELED;
  }

  disp = XOpenDisplay(NULL);
  XSetErrorHandler(XEH);

  XrmInitialize();
  update_gtkrc();
  if(dump) drop_out(0);

  XSelectInput(disp, RootWindow(disp, DefaultScreen(disp)), PropertyChangeMask);
  while(run) {
    XEvent event;
    XNextEvent(disp, &event);
    if((event.type == PropertyNotify)
       && (event.xproperty.atom == XA_RESOURCE_MANAGER)) update_gtkrc();
  }
  drop_out(0);
}
